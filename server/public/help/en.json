{
  "logLevel": "Verbosity of the program; available values are \"error\", \"warn\", \"info\", \"debug\".",
  "logDestinations": "Destinations of log messages; available values are \"stdout\", \"file\" and \"syslog\".",
  "logFile": "If \"file\" is in logDestinations, this is the file which will receive the logs.",
  "sysLogPrefix": "If \"syslog\" is in logDestinations, use prefix for logs.",
  "readTimeout": "Timeout of read operations.",
  "writeTimeout": "Timeout of write operations.",
  "writeQueueSize": "Size of the queue of outgoing packets. A higher value allows to increase throughput, a lower value allows to save RAM.",
  "udpMaxPayloadSize": "Maximum size of outgoing UDP packets. This can be decreased to avoid fragmentation on networks with a low UDP MTU.",
  "udpReadBufferSize": "Size of the read buffer of every UDP socket. This can be increased to decrease packet losses. It defaults to the default value of the operating system.",
  "runOnConnect": "Command to run when a client connects to the server. This is terminated with SIGINT when a client disconnects from the server. The following environment variables are available: * MTX_CONN_TYPE: connection type * MTX_CONN_ID: connection ID * RTSP_PORT: RTSP server port",
  "runOnConnectRestart": "Restart the command if it exits.",
  "runOnDisconnect": "Command to run when a client disconnects from the server. Environment variables are the same of runOnConnect.",
  "authMethod": "Authentication method. Available values are: * internal: credentials are stored in the configuration file * http: an external HTTP URL is contacted to perform authentication * jwt: an external identity server provides authentication through JWTs",
  "authInternalUsers": "Internal authentication. list of users.",
  "pass": "Default administrator. This allows to use API, metrics and PPROF without authentication, if the IP is localhost.",
  "ips": "",
  "permissions": "",
  "path": "",
  "authHTTPAddress": "HTTP-based authentication. URL called to perform authentication. Every time a user wants to authenticate, the server calls this URL with the POST method and a body containing: \"user\": \"user\", \"password\": \"password\", \"token\": \"token\", \"ip\": \"ip\", \"action\": \"publish|read|playback|api|metrics|pprof\", \"path\": \"path\", \"protocol\": \"rtsp|rtmp|hls|webrtc|srt\", \"id\": \"id\", \"query\": \"query\" If the response code is 20x, authentication is accepted, otherwise it is discarded.",
  "authHTTPExclude": "Actions to exclude from HTTP-based authentication. Format is the same as the one of user permissions.",
  "authJWTJWKS": "JWT-based authentication. Users have to login through an external identity server and obtain a JWT. This JWT must contain the claim \"mediamtx_permissions\" with permissions, for instance: \"mediamtx_permissions\": [ \"action\": \"publish\", \"path\": \"somepath\" Users are expected to pass the JWT in the Authorization header or as password. This is the JWKS URL that will be used to pull (once) the public key that allows to validate JWTs.",
  "authJWTJWKSFingerprint": "If the JWKS URL has a self-signed or invalid certificate, you can provide the fingerprint of the certificate in order to validate it anyway. It can be obtained by running: openssl s_client -connect jwt_jwks_domain:443 </dev/null 2>/dev/null | sed -n '/BEGIN/,/END/p' > server.crt openssl x509 -in server.crt -noout -fingerprint -sha256 | cut -d \"=\" -f2 | tr -d ':'",
  "authJWTClaimKey": "name of the claim that contains permissions.",
  "authJWTExclude": "Actions to exclude from JWT-based authentication. Format is the same as the one of user permissions.",
  "authJWTInHTTPQuery": "allow passing the JWT through query parameters of HTTP requests (i.e. ?jwt=JWT). This is a security risk and will be disabled by default in the future.",
  "api": "Enable controlling the server through the Control API.",
  "apiAddress": "Address of the Control API listener.",
  "apiEncryption": "Enable TLS/HTTPS on the Control API server.",
  "apiServerKey": "Path to the server key. This is needed only when encryption is yes. This can be generated with: openssl genrsa -out server.key 2048 openssl req -new -x509 -sha256 -key server.key -out server.crt -days 3650",
  "apiServerCert": "Path to the server certificate.",
  "apiAllowOrigins": "List of allowed CORS origins. Supports wildcards: ['http://*.example.com']",
  "apiTrustedProxies": "List of IPs or CIDRs of proxies placed before the HTTP server. If the server receives a request from one of these entries, IP in logs will be taken from the X-Forwarded-For header.",
  "metrics": "Enable Prometheus-compatible metrics.",
  "metricsAddress": "Address of the metrics HTTP listener.",
  "metricsEncryption": "Enable TLS/HTTPS on the Metrics server.",
  "metricsServerKey": "Path to the server key. This is needed only when encryption is yes. This can be generated with: openssl genrsa -out server.key 2048 openssl req -new -x509 -sha256 -key server.key -out server.crt -days 3650",
  "metricsServerCert": "Path to the server certificate.",
  "metricsAllowOrigins": "List of allowed CORS origins. Supports wildcards: ['http://*.example.com']",
  "metricsTrustedProxies": "List of IPs or CIDRs of proxies placed before the HTTP server. If the server receives a request from one of these entries, IP in logs will be taken from the X-Forwarded-For header.",
  "pprof": "Enable pprof-compatible endpoint to monitor performances.",
  "pprofAddress": "Address of the pprof listener.",
  "pprofEncryption": "Enable TLS/HTTPS on the pprof server.",
  "pprofServerKey": "Path to the server key. This is needed only when encryption is yes. This can be generated with: openssl genrsa -out server.key 2048 openssl req -new -x509 -sha256 -key server.key -out server.crt -days 3650",
  "pprofServerCert": "Path to the server certificate.",
  "pprofAllowOrigins": "List of allowed CORS origins. Supports wildcards: ['http://*.example.com']",
  "pprofTrustedProxies": "List of IPs or CIDRs of proxies placed before the HTTP server. If the server receives a request from one of these entries, IP in logs will be taken from the X-Forwarded-For header.",
  "playback": "Enable downloading recordings from the playback server.",
  "playbackAddress": "Address of the playback server listener.",
  "playbackEncryption": "Enable TLS/HTTPS on the playback server.",
  "playbackServerKey": "Path to the server key. This is needed only when encryption is yes. This can be generated with: openssl genrsa -out server.key 2048 openssl req -new -x509 -sha256 -key server.key -out server.crt -days 3650",
  "playbackServerCert": "Path to the server certificate.",
  "playbackAllowOrigins": "List of allowed CORS origins. Supports wildcards: ['http://*.example.com']",
  "playbackTrustedProxies": "List of IPs or CIDRs of proxies placed before the HTTP server. If the server receives a request from one of these entries, IP in logs will be taken from the X-Forwarded-For header.",
  "rtsp": "Enable publishing and reading streams with the RTSP protocol.",
  "rtspTransports": "List of enabled RTSP transport protocols. UDP is the most performant, but doesn't work when there's a NAT/firewall between server and clients. UDP-multicast allows to save bandwidth when clients are all in the same LAN. TCP is the most versatile. The handshake is always performed with TCP.",
  "rtspEncryption": "Use secure protocol variants (RTSPS, TLS, SRTP). Available values are \"no\", \"strict\", \"optional\".",
  "rtspAddress": "Address of the TCP/RTSP listener. This is needed only when encryption is \"no\" or \"optional\".",
  "rtspsAddress": "Address of the TCP/TLS/RTSPS listener. This is needed only when encryption is \"strict\" or \"optional\".",
  "rtpAddress": "Address of the UDP/RTP listener. This is needed only when \"udp\" is in rtspTransports.",
  "rtcpAddress": "Address of the UDP/RTCP listener. This is needed only when \"udp\" is in rtspTransports.",
  "multicastIPRange": "IP range of all UDP-multicast listeners. This is needed only when \"multicast\" is in rtspTransports.",
  "multicastRTPPort": "Port of all UDP-multicast/RTP listeners. This is needed only when \"multicast\" is in rtspTransports.",
  "multicastRTCPPort": "Port of all UDP-multicast/RTCP listeners. This is needed only when \"multicast\" is in rtspTransports.",
  "srtpAddress": "Address of the UDP/SRTP listener. This is needed only when \"udp\" is in rtspTransports and encryption is enabled.",
  "srtcpAddress": "Address of the UDP/SRTCP listener. This is needed only when \"udp\" is in rtspTransports and encryption is enabled.",
  "multicastSRTPPort": "Port of all UDP-multicast/SRTP listeners. This is needed only when \"multicast\" is in rtspTransports and encryption is enabled.",
  "multicastSRTCPPort": "Port of all UDP-multicast/SRTCP listeners. This is needed only when \"multicast\" is in rtspTransports and encryption is enabled.",
  "rtspServerKey": "Path to the server key. This is needed only when encryption is \"strict\" or \"optional\". This can be generated with: openssl genrsa -out server.key 2048 openssl req -new -x509 -sha256 -key server.key -out server.crt -days 3650",
  "rtspServerCert": "Path to the server certificate. This is needed only when encryption is \"strict\" or \"optional\".",
  "rtspAuthMethods": "Authentication methods. Available are \"basic\" and \"digest\". \"digest\" doesn't provide any additional security and is available for compatibility only.",
  "rtmp": "Enable publishing and reading streams with the RTMP protocol.",
  "rtmpAddress": "Address of the RTMP listener. This is needed only when encryption is \"no\" or \"optional\".",
  "rtmpEncryption": "Encrypt connections with TLS (RTMPS). Available values are \"no\", \"strict\", \"optional\".",
  "rtmpsAddress": "Address of the RTMPS listener. This is needed only when encryption is \"strict\" or \"optional\".",
  "rtmpServerKey": "Path to the server key. This is needed only when encryption is \"strict\" or \"optional\". This can be generated with: openssl genrsa -out server.key 2048 openssl req -new -x509 -sha256 -key server.key -out server.crt -days 3650",
  "rtmpServerCert": "Path to the server certificate. This is needed only when encryption is \"strict\" or \"optional\".",
  "hls": "Enable reading streams with the HLS protocol.",
  "hlsAddress": "Address of the HLS listener.",
  "hlsEncryption": "Enable TLS/HTTPS on the HLS server. This is required for Low-Latency HLS.",
  "hlsServerKey": "Path to the server key. This is needed only when encryption is yes. This can be generated with: openssl genrsa -out server.key 2048 openssl req -new -x509 -sha256 -key server.key -out server.crt -days 3650",
  "hlsServerCert": "Path to the server certificate.",
  "hlsAllowOrigins": "List of allowed CORS origins. Supports wildcards: ['http://*.example.com']",
  "hlsTrustedProxies": "List of IPs or CIDRs of proxies placed before the HLS server. If the server receives a request from one of these entries, IP in logs will be taken from the X-Forwarded-For header.",
  "hlsAlwaysRemux": "By default, HLS is generated only when requested by a user. This option allows to generate it always, avoiding the delay between request and generation.",
  "hlsVariant": "Variant of the HLS protocol to use. Available options are: * mpegts - uses MPEG-TS segments, for maximum compatibility. * fmp4 - uses fragmented MP4 segments, more efficient. * lowLatency - uses Low-Latency HLS.",
  "hlsSegmentCount": "Number of HLS segments to keep on the server. Segments allow to seek through the stream. Their number doesn't influence latency.",
  "hlsSegmentDuration": "Minimum duration of each segment. A player usually puts 3 segments in a buffer before reproducing the stream. The final segment duration is also influenced by the interval between IDR frames, since the server changes the duration in order to include at least one IDR frame in each segment.",
  "hlsPartDuration": "Minimum duration of each part. A player usually puts 3 parts in a buffer before reproducing the stream. Parts are used in Low-Latency HLS in place of segments. Part duration is influenced by the distance between video/audio samples and is adjusted in order to produce segments with a similar duration.",
  "hlsSegmentMaxSize": "Maximum size of each segment. This prevents RAM exhaustion.",
  "hlsDirectory": "Directory in which to save segments, instead of keeping them in the RAM. This decreases performance, since reading from disk is less performant than reading from RAM, but allows to save RAM.",
  "hlsMuxerCloseAfter": "The muxer will be closed when there are no reader requests and this amount of time has passed.",
  "webrtc": "Enable publishing and reading streams with the WebRTC protocol.",
  "webrtcAddress": "Address of the WebRTC HTTP listener.",
  "webrtcEncryption": "Enable TLS/HTTPS on the WebRTC server.",
  "webrtcServerKey": "Path to the server key. This can be generated with: openssl genrsa -out server.key 2048 openssl req -new -x509 -sha256 -key server.key -out server.crt -days 3650",
  "webrtcServerCert": "Path to the server certificate.",
  "webrtcAllowOrigins": "List of allowed CORS origins. Supports wildcards: ['http://*.example.com']",
  "webrtcTrustedProxies": "List of IPs or CIDRs of proxies placed before the WebRTC server. If the server receives a request from one of these entries, IP in logs will be taken from the X-Forwarded-For header.",
  "webrtcLocalUDPAddress": "Address of a local UDP listener that will receive connections. Use a blank string to disable.",
  "webrtcLocalTCPAddress": "Address of a local TCP listener that will receive connections. This is disabled by default since TCP is less efficient than UDP and introduces a progressive delay when network is congested.",
  "webrtcIPsFromInterfaces": "WebRTC clients need to know the IP of the server. Gather IPs from interfaces and send them to clients.",
  "webrtcIPsFromInterfacesList": "List of interfaces whose IPs will be sent to clients. An empty value means to use all available interfaces.",
  "webrtcAdditionalHosts": "List of additional hosts or IPs to send to clients.",
  "webrtcICEServers2": "ICE servers. Needed only when local listeners can't be reached by clients. STUN servers allows to obtain and share the public IP of the server. TURN/TURNS servers forces all traffic through them.",
  "webrtcHandshakeTimeout": "- url: stun:stun.l.google.com:19302 if user is \"AUTH_SECRET\", then authentication is secret based. the secret must be inserted into the password field. username: '' password: '' clientOnly: false Time to wait for the WebRTC handshake to complete.",
  "webrtcTrackGatherTimeout": "Maximum time to gather video tracks.",
  "webrtcSTUNGatherTimeout": "The maximum time to gather STUN candidates.",
  "srt": "Enable publishing and reading streams with the SRT protocol.",
  "srtAddress": "Address of the SRT listener.",
  "pathDefaults": "Settings in \"pathDefaults\" are applied anywhere, unless they are overridden in \"paths\".",
  "source": "Source of the stream. This can be: * publisher -> the stream is provided by a RTSP, RTMP, WebRTC or SRT client * rtsp://existing-url -> the stream is pulled from another RTSP server / camera * rtsps://existing-url -> the stream is pulled from another RTSP server / camera with RTSPS * rtsp+http://existing-url -> the stream is pulled from another RTSP server / camera, with HTTP tunneling * rtsps+http://existing-url -> the stream is pulled from another RTSP server / camera, with HTTPS tunneling * rtsp+ws://existing-url -> the stream is pulled from another RTSP server / camera, with WebSocket tunneling * rtsps+ws://existing-url -> the stream is pulled from another RTSP server / camera, with secure WebSocket tunneling * rtmp://existing-url -> the stream is pulled from another RTMP server / camera * rtmps://existing-url -> the stream is pulled from another RTMP server / camera with RTMPS * http://existing-url/stream.m3u8 -> the stream is pulled from another HLS server / camera * https://existing-url/stream.m3u8 -> the stream is pulled from another HLS server / camera with HTTPS * udp+mpegts://ip:port -> the stream is pulled from MPEG-TS over UDP, by listening on the specified address * unix+mpegts://socket -> the stream is pulled from MPEG-TS over Unix socket, by using the socket * udp+rtp://ip:port -> the stream is pulled from RTP over UDP, by listening on the specified address * unix+rtp://socket -> the stream is pulled from RTP over Unix socket, by using the socket * srt://existing-url -> the stream is pulled from another SRT server / camera * whep://existing-url -> the stream is pulled from another WebRTC server / camera * wheps://existing-url -> the stream is pulled from another WebRTC server / camera with HTTPS * redirect -> the stream is provided by another path or server * rpiCamera -> the stream is provided by a Raspberry Pi Camera The following variables can be used in the source string: * $MTX_QUERY: query parameters (passed by first reader) * $G1, $G2, ...: regular expression groups, if path name is a regular expression.",
  "sourceFingerprint": "If the source is a URL, and the source TLS certificate is self-signed or invalid, you can provide the fingerprint of the certificate in order to validate it anyway. It can be obtained by running: openssl s_client -connect source_ip:source_port </dev/null 2>/dev/null | sed -n '/BEGIN/,/END/p' > server.crt openssl x509 -in server.crt -noout -fingerprint -sha256 | cut -d \"=\" -f2 | tr -d ':'",
  "sourceOnDemand": "If the source is a URL, it will be pulled only when at least one reader is connected, saving bandwidth.",
  "sourceOnDemandStartTimeout": "If sourceOnDemand is \"yes\", readers will be put on hold until the source is ready or until this amount of time has passed.",
  "sourceOnDemandCloseAfter": "If sourceOnDemand is \"yes\", the source will be closed when there are no readers connected and this amount of time has passed.",
  "maxReaders": "Maximum number of readers. Zero means no limit.",
  "srtReadPassphrase": "SRT encryption passphrase required to read from this path.",
  "fallback": "If the stream is not available, redirect readers to this path. It can be can be a relative path (i.e. /otherstream) or an absolute RTSP URL.",
  "useAbsoluteTimestamp": "Use absolute timestamp of frames, instead of replacing them with the current time.",
  "record": "Record streams to disk.",
  "recordPath": "Path of recording segments. Extension is added automatically. Available variables are %path (path name), %Y %m %d (year, month, day), %H %M %S (hours, minutes, seconds), %f (microseconds), %z (time zone), %s (unix epoch).",
  "recordFormat": "Format of recorded segments. Available formats are \"fmp4\" (fragmented MP4) and \"mpegts\" (MPEG-TS).",
  "recordPartDuration": "fMP4 segments are concatenation of small MP4 files (parts), each with this duration. MPEG-TS segments are concatenation of 188-bytes packets, flushed to disk with this period. When a system failure occurs, the last part gets lost. Therefore, the part duration is equal to the RPO (recovery point objective).",
  "recordMaxPartSize": "This prevents RAM exhaustion.",
  "recordSegmentDuration": "Minimum duration of each segment.",
  "recordDeleteAfter": "Delete segments after this timespan. Set to 0s to disable automatic deletion.",
  "overridePublisher": "Default path settings -> Publisher source (when source is \"publisher\") Allow another client to disconnect the current publisher and publish in its place.",
  "srtPublishPassphrase": "SRT encryption passphrase required to publish to this path.",
  "rtspTransport": "Default path settings -> RTSP source (when source is a RTSP or a RTSPS URL) Transport protocol used to pull the stream. available values are \"automatic\", \"udp\", \"multicast\", \"tcp\".",
  "rtspAnyPort": "Support sources that don't provide server ports or use random server ports. This is a security issue and must be used only when interacting with sources that require it.",
  "rtspRangeType": "Range header to send to the source, in order to start streaming from the specified offset. available values: * clock: Absolute time * npt: Normal Play Time * smpte: SMPTE timestamps relative to the start of the recording",
  "rtspRangeStart": "Available values: * clock: UTC ISO 8601 combined date and time string, e.g. 20230812T120000Z * npt: duration such as \"300ms\", \"1.5m\" or \"2h45m\", valid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\" * smpte: duration such as \"300ms\", \"1.5m\" or \"2h45m\", valid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\"",
  "rtpSDP": "Default path settings -> RTP source (when source is RTP) session description protocol (SDP) of the RTP stream.",
  "sourceRedirect": "Default path settings -> Redirect source (when source is \"redirect\") path which clients will be redirected to. It can be can be a relative path (i.e. /otherstream) or an absolute RTSP URL.",
  "rpiCameraCamID": "Default path settings -> Raspberry Pi Camera source (when source is \"rpiCamera\") ID of the camera.",
  "rpiCameraSecondary": "Whether this is a secondary stream.",
  "rpiCameraWidth": "Width of frames.",
  "rpiCameraHeight": "Height of frames.",
  "rpiCameraHFlip": "Flip horizontally.",
  "rpiCameraVFlip": "Flip vertically.",
  "rpiCameraBrightness": "Brightness [-1, 1].",
  "rpiCameraContrast": "Contrast [0, 16].",
  "rpiCameraSaturation": "Saturation [0, 16].",
  "rpiCameraSharpness": "Sharpness [0, 16].",
  "rpiCameraExposure": "Exposure mode. values: normal, short, long, custom.",
  "rpiCameraAWB": "Auto-white-balance mode. (auto, incandescent, tungsten, fluorescent, indoor, daylight, cloudy or custom).",
  "rpiCameraAWBGains": "Auto-white-balance fixed gains. This can be used in place of rpiCameraAWB. format: [red,blue].",
  "rpiCameraDenoise": "Denoise operating mode (off, cdn_off, cdn_fast, cdn_hq).",
  "rpiCameraShutter": "Fixed shutter speed, in microseconds.",
  "rpiCameraMetering": "Metering mode of the AEC/AGC algorithm (centre, spot, matrix or custom).",
  "rpiCameraGain": "Fixed gain.",
  "rpiCameraEV": "EV compensation of the image in range [-10, 10].",
  "rpiCameraROI": "Region of interest, in format x,y,width,height (all normalized between 0 and 1).",
  "rpiCameraHDR": "Whether to enable HDR on Raspberry Camera 3.",
  "rpiCameraTuningFile": "Tuning file.",
  "rpiCameraMode": "Sensor mode, in format [width]:[height]:[bit-depth]:[packing] bit-depth and packing are optional.",
  "rpiCameraFPS": "frames per second.",
  "rpiCameraAfMode": "Autofocus mode (auto, manual or continuous).",
  "rpiCameraAfRange": "Autofocus range (normal, macro or full).",
  "rpiCameraAfSpeed": "Autofocus speed (normal or fast).",
  "rpiCameraLensPosition": "Lens position (for manual autofocus only), will be set to focus to a specific distance calculated by the following formula: d = 1 / value Examples: 0 moves the lens to infinity. 0.5 moves the lens to focus on objects 2m away. 2 moves the lens to focus on objects 50cm away.",
  "rpiCameraAfWindow": "Autofocus window, in the form x,y,width,height where the coordinates are given as a proportion of the entire image.",
  "rpiCameraFlickerPeriod": "Manual flicker correction period, in microseconds.",
  "rpiCameraTextOverlayEnable": "Enables printing text on each frame.",
  "rpiCameraTextOverlay": "Text that is printed on each frame. format is the one of the strftime() function.",
  "rpiCameraCodec": "Codec (auto, hardwareH264, softwareH264 or mjpeg). When is \"auto\" and stream is primary, it defaults to hardwareH264 (if available) or softwareH264. When is \"auto\" and stream is secondary, it defaults to mjpeg.",
  "rpiCameraIDRPeriod": "Period between IDR frames (when codec is hardwareH264 or softwareH264).",
  "rpiCameraBitrate": "Bitrate (when codec is hardwareH264 or softwareH264).",
  "rpiCameraHardwareH264Profile": "Hardware H264 profile (baseline, main or high) (when codec is hardwareH264).",
  "rpiCameraHardwareH264Level": "Hardware H264 level (4.0, 4.1 or 4.2) (when codec is hardwareH264).",
  "rpiCameraSoftwareH264Profile": "Software H264 profile (baseline, main or high) (when codec is softwareH264).",
  "rpiCameraSoftwareH264Level": "Software H264 level (4.0, 4.1 or 4.2) (when codec is softwareH264).",
  "rpiCameraMJPEGQuality": "M-JPEG JPEG quality (when codec is mjpeg).",
  "runOnInit": "Command to run when this path is initialized. This can be used to publish a stream when the server is launched. This is terminated with SIGINT when the program closes. The following environment variables are available: * MTX_PATH: path name * RTSP_PORT: RTSP server port * G1, G2, ...: regular expression groups, if path name is a regular expression.",
  "runOnInitRestart": "Restart the command if it exits.",
  "runOnDemand": "Command to run when this path is requested by a reader and no one is publishing to this path yet. This can be used to publish a stream on demand. This is terminated with SIGINT when there are no readers anymore. The following environment variables are available: * MTX_PATH: path name * MTX_QUERY: query parameters (passed by first reader) * RTSP_PORT: RTSP server port * G1, G2, ...: regular expression groups, if path name is a regular expression.",
  "runOnDemandRestart": "Restart the command if it exits.",
  "runOnDemandStartTimeout": "Readers will be put on hold until the runOnDemand command starts publishing or until this amount of time has passed.",
  "runOnDemandCloseAfter": "The command will be closed when there are no readers connected and this amount of time has passed.",
  "runOnUnDemand": "Command to run when there are no readers anymore. Environment variables are the same of runOnDemand.",
  "runOnReady": "Command to run when the stream is ready to be read, whenever it is published by a client or pulled from a server / camera. This is terminated with SIGINT when the stream is not ready anymore. The following environment variables are available: * MTX_PATH: path name * MTX_QUERY: query parameters (passed by publisher) * MTX_SOURCE_TYPE: source type * MTX_SOURCE_ID: source ID * RTSP_PORT: RTSP server port * G1, G2, ...: regular expression groups, if path name is a regular expression.",
  "runOnReadyRestart": "Restart the command if it exits.",
  "runOnNotReady": "Command to run when the stream is not available anymore. Environment variables are the same of runOnReady.",
  "runOnRead": "Command to run when a client starts reading. This is terminated with SIGINT when a client stops reading. The following environment variables are available: * MTX_PATH: path name * MTX_QUERY: query parameters (passed by reader) * MTX_READER_TYPE: reader type * MTX_READER_ID: reader ID * RTSP_PORT: RTSP server port * G1, G2, ...: regular expression groups, if path name is a regular expression.",
  "runOnReadRestart": "Restart the command if it exits.",
  "runOnUnread": "Command to run when a client stops reading. Environment variables are the same of runOnRead.",
  "runOnRecordSegmentCreate": "Command to run when a recording segment is created. The following environment variables are available: * MTX_PATH: path name * MTX_SEGMENT_PATH: segment file path * RTSP_PORT: RTSP server port * G1, G2, ...: regular expression groups, if path name is a regular expression.",
  "runOnRecordSegmentComplete": "Command to run when a recording segment is complete. The following environment variables are available: * MTX_PATH: path name * MTX_SEGMENT_PATH: segment file path * MTX_SEGMENT_DURATION: segment duration * RTSP_PORT: RTSP server port * G1, G2, ...: regular expression groups, if path name is a regular expression.",
  "paths": "Path settings Settings in \"paths\" are applied to specific paths, and the map key is the name of the path. Any setting in \"pathDefaults\" can be overridden here. It's possible to use regular expressions by using a tilde as prefix, for example \"~^(test1|test2)$\" will match both \"test1\" and \"test2\", for example \"~^prefix\" will match all paths that start with \"prefix\".",
  "all_others": "example: my_camera: source: rtsp://my_camera Settings under path \"all_others\" are applied to all paths that do not match another entry."
}